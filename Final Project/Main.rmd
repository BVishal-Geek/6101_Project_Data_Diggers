---
title: "EVALUATING ASTEROID CHARACTERISTICS AND CLASSIFYING ASTEROID THREAT ON PLANET EARTH"
author: "Vishal Bakshi, Pratiksha Dange, Sudanshu Dotel, Qibin Huang"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    number_sections: false
    toc: yes
    toc_depth: 3
    toc_float: yes
---


```{r init, include=FALSE}
# some of common options (and the defaults) are: 
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right', 
library(ezids)
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
options(scientific=T, digits = 3) 
library(dplyr)
library(kableExtra)
library(ggplot2)
library(psych)

# options(scipen=9, digits = 3)  
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.

# use scipen=999 to prevent scientific notation at all times
```


## Step:1: Importing Dataset & Checking Summary Statistics

```{r, include=TRUE, echo=TRUE, results='show'}
# current_directory <- "/Users/vishal/Desktop/Way to New World/University/01_All_Semesters/01_Semester/03_Projects/01_DS/6101_Project_Data_Diggers/"
# data_path <- "Datasets/Asteroid_Hazard_Classification.csv"
# file_path <- file.path(dirname(current_directory), data_path)
Ast_raw <- data.frame(read.csv("Asteroid_Hazard_Classification.csv"))


kable(summary(Ast_raw), "html") %>%
  kable_paper(full_width = FALSE) %>% 
  scroll_box(width = "100%", height = "400px")


```



## Step:2: Data Preprocessing

### Step : 2.1 : Converting the Hazard column from string to integer, and into categorical.

```{r, include=TRUE, echo=TRUE, results='show'}
Ast_raw <- Ast_raw %>%
mutate(Hazardous = as.integer(Hazardous))#(1 is True, 0 is False)

Ast_raw$Hazardous <- as.factor(Ast_raw$Hazardous)

kable(Ast_raw, "html") %>%
  kable_paper(full_width = FALSE) %>% 
  scroll_box(width = "100%", height = "400px")




```


### Step : 2.2 : Dropping columns which are not required for our analysis:

```{r, include=TRUE, echo=TRUE, results='asis'}

# According to the domain knowledge we acquired from the specific domain, these are the important variables which is mostly affecting the asteroid to be hazardous. 

selected_columns <- c('Absolute.Magnitude', 'Est.Dia.in.KM.max.','Miss.Dist..kilometers.','Relative.Velocity.km.per.sec', 'Minimum.Orbit.Intersection','Jupiter.Tisserand.Invariant', 'Eccentricity', 'Semi.Major.Axis', 'Inclination','Asc.Node.Longitude' ,'Orbital.Period' ,'Perihelion.Distance','Perihelion.Arg', 'Perihelion.Time','Mean.Anomaly','Aphelion.Dist', 'Mean.Motion', 'Hazardous')

Filtered_data <- subset(Ast_raw, select = selected_columns)

# Create a nicely formatted table
kable(head(Filtered_data), "html") %>%
  kable_paper(full_width = FALSE) %>% 
  scroll_box(width = "100%", height = "400px")


```

### Step : 2.3: Correlation Plot 

```{r, include= TRUE, echo=TRUE, results='markup'}

library(corrplot)

subset <- as.data.frame(lapply(Filtered_data[1:17], as.numeric))
par(mfrow = c(1, 1)) # Adjust mar and oma for margins

M = cor(subset)
corrplot(M, method = 'number', number.cex = 0.8, tl.cex = 0.8)

```
The reason to drop the columns is to easily carry out the inferences and also according to the domain knowledge we acquired, the columns which we dropped are not very useful for our analysis. 

Some of the columns are showing high multi-collinearity. We are dropping them such that we don't face any issue with the model. 

### Step : 2.4 : Histogram Plot

```{r, include=TRUE, echo=TRUE, results='markup'}
histplots <- function(column) {
  Plot <- ggplot(Filtered_data, aes_string(x = column, group = "1")) +
    geom_histogram(color="green", fill = "blue",bins=30)  + ggtitle("Hist Plots", column )
  return(Plot)
  
}

for(col in colnames(Filtered_data[1:17])) { 
  print(histplots(col))
}

```

### Step : 2.5: Box Plots of all the variables before outlier removal

```{r, include=TRUE, echo=TRUE, results='markup'}
str(Filtered_data)
boxPlots <- function(column){
  Plot <- ggplot(Filtered_data, aes_string(x = column, group = "1")) +
    geom_boxplot() + coord_flip() + ggtitle("Box Plots", column )
  return(Plot)
}

for(col in colnames(Filtered_data[1:17])) { 
  print(boxPlots(col))
}




```

By carefully observing the box plots, there are some of the variables which have outliers and highly skewed. However we have to check the skewness after removing the outliers. 

### Step : 2.6 : Outlier Removal

```{r, include=TRUE, echo=TRUE, results='markup'}
reduced_df <- Filtered_data

columns_to_check <- c("Est.Dia.in.KM.max.","Relative.Velocity.km.per.sec", "Minimum.Orbit.Intersection", "Semi.Major.Axis", "Inclination", "Orbital.Period", "Perihelion.Time", "Aphelion.Dist", "Mean.Motion")
# Function to remove outliers based on IQR
remove_outliers <- function(x) {
  Q1 <- quantile(x, 0.25)
  Q3 <- quantile(x, 0.75)
  IQR_val <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR_val
  upper_bound <- Q3 + 1.5 * IQR_val
  return(ifelse(x >= lower_bound & x <= upper_bound, x, NA))
}

# Loop through columns (except 'Hazardous') and remove outliers
for (col in columns_to_check) {
  reduced_df[[col]] <- remove_outliers(reduced_df[[col]])
}

# Remove rows containing NA values after outlier removal
reduced_df <- reduced_df[complete.cases(reduced_df), ]

str(reduced_df)

```


### Step : 2.7 : Box Plots of all the variables before outlier removal. 

```{r, include=TRUE, echo=TRUE, results='markup'}

boxPlots_ <- function(column){
  Plot <- ggplot(reduced_df, aes_string(x = column, group = "1")) +
    geom_boxplot() + coord_flip() + ggtitle("Box Plots", column )
  return(Plot)
}

for(col in colnames(reduced_df[1:17])) { 
  print(boxPlots_(col))
}


```
### Step : 2.8 : Checking for Non-Null Values

```{r, include=TRUE, echo=TRUE, results='markup'}
null_values <- colSums(is.na(reduced_df))
null_values

```

### Step : 2.9 : Skewness check using QQ-Plot

```{r}
qqplt <- function(df, col) {
  
  # Before Outlier Removal
  if (!all(is.na(Filtered_data[[col]]))) {
    qqnorm(Filtered_data[[col]], main = paste("Before Outlier Removal", col))
    qqline(Filtered_data[[col]])
  } else {
    cat("Skipping plot for", col, "due to missing or NA values.\n")
  }
  
  # After Outlier Removal
  if (!all(is.na(reduced_df[[col]]))) {
    qqnorm(reduced_df[[col]], main = paste("After Outlier Removal", col))
    qqline(reduced_df[[col]])
  } else {
    cat("Skipping plot for", col, "due to missing or NA values after outlier removal.\n")
  }
}

# Assuming 'columns_to_check' is a vector containing the column names you want to check

for (col in columns_to_check) {
  qqplt(df,col)
}

```


### Step : 2.10 : Skewness removal using Log Transformation. 

```{r}
# Applying Log Transformation on diameter. 
# Assuming your data frame is named 'reduced_df'
# Perform log transformation

reduced_df[["Log_Est_Diameter"]] <- log(reduced_df[["Est.Dia.in.KM.max."]])

hist(reduced_df$Est.Dia.in.KM.max., main = "Histogram of Diameter Before Log Transformation")
hist(reduced_df$Log_Est_Diameter, main = "Histogram of Diameter After Log Transformation")

```

```{r, include=TRUE, echo=TRUE, results='markup'}
# As we already have the `Log Transformation of Estimated Diameter`. We can drop `Est.Dia.in.KM.max.`. We will create two variables for `No Sampling` and for `SMOTE Sampling`.
data1 <- reduced_df[,-which(names(reduced_df) == "Est.Dia.in.KM.max.")]
dataSmote <- reduced_df[,-which(names(reduced_df) == "Est.Dia.in.KM.max.")]


```

### Step : 2.11 : Checking for Multi-Collinearity. 

```{r, include=TRUE, echo=TRUE, results='markup'}

# Check for Multicollinearity using Variance Inflation Factor. 
library(car)
# Assuming Hazardous is a binary outcome (0 or 1)
logistic_model <- glm(Hazardous ~ ., data = data1, family = "binomial")

# Check VIF for multicollinearity
vif_values <- car::vif(logistic_model)

# Print variables with VIF greater than or equal to 10
high_vif_variables <- names(vif_values)[vif_values >= 8]
print(high_vif_variables)

```

```{r}
# Since we have Multi-Collineairity with "Absolute.Magnitude", "Jupiter.Tisserand.Invariant" "Orbital.Period", "Aphelion.Dist", "Mean.Motion". However, Absolute Magnitiude, Jupiter Tisserand Invariant are very important columns. 

# Assuming you want to remove specific columns from reduced_df
columns_to_remove <- c("Orbital.Period", "Aphelion.Dist", "Mean.Motion")

data1 <- data1[, -which(names(data1) %in% columns_to_remove)]
dataSmote <- dataSmote[, -which(names(dataSmote) %in% columns_to_remove)]

```

```{r}
# Count plot using ggplot2
ggplot(data1, aes(x = Hazardous, fill = Hazardous)) +
  geom_bar() +
  labs(title = 'Distribution of Hazardous Asteroids - Before Sampling',
       x = 'Hazardous',
       y = 'Count') +
  scale_fill_manual(values = c('skyblue', 'salmon')) +
  theme_minimal()
```

```{r}

library(ROSE)
library(smotefamily)
library(ggplot2)

# Assuming Hazardous is a binary factor variable
data1$Hazardous <- as.factor(data1$Hazardous)

# Applying SMOTE
dataSmote_rose <- ovun.sample(Hazardous ~ ., data = data1, method = "over")

# Extracting the sampled data
dataSmote <- dataSmote_rose$data

# Count plot using ggplot2
ggplot(dataSmote, aes(x = Hazardous, fill = Hazardous)) +
  geom_bar() +
  labs(title = 'After Distribution of Hazardous Asteroids - After SMOTE',
       x = 'Hazardous',
       y = 'Count') +
  scale_fill_manual(values = c('skyblue', 'salmon')) +
  theme_minimal()


```
Note: Points to consider before jumping to your steps

1. We have two variable with and without sampling. 
2. without sampling: data1 
3. with sampling: dataSmote


Pending tasks to be implemented: 


### Roger 

1. Scatter plot for Diameter vs Velocity -- use data1 data set to do this
2. Anova test for Diamter vs velocity w.r.t Hazardous



### Pratiksha's Part 
#test
1. Logistic regression with data1(without sampling)
2. Logistic regression with dataSmote(with sampling)
```{r}
# Logistic Regression without Sampling


data1$Hazardous <- as.factor(data1$Hazardous)
logistic_model <- glm(Hazardous ~ ., data = data1, family = "binomial") 
summary(logistic_model) 
```

```{r}

# Logistic Regression with Sampling

logistic_model_smote <- glm(Hazardous ~ ., data = dataSmote, family = "binomial")   
summary(logistic_model_smote)
```



### Sudhanshu 
3. Logistic regression with data 1(without sampling - Hyper Parameter Tuning)


### Roger
1. Random Forest with data1(without sampling)
2. Random Forest with dataSmote(with sampling)

